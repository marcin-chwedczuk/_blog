---
layout: post
cover: 'assets/images/devoxx_cover.jpeg'
title: Devoxx Poland 2018
date: 2018-06-25 00:00:00
tags: devcon jvmbloggers 
subclass: 'post tag-test tag-content'
categories: 'mc'
navigation: True
logo: 'assets/images/home.png'
disqus: true
---

### About conference

TODO:
- Opening and book

### My notes from presentations

#### State or events? Which shall I keep? by Jakub Pilimon

- You can find most of the topics addressed by Mr. Jakub in his blog
 post 
 [Event Storming and Spring with a Splash of DDD](https://spring.io/blog/2018/04/11/event-storming-and-spring-with-a-splash-of-ddd).
- ORM's can introduce 
 [accidental complexity](https://en.wikipedia.org/wiki/No_Silver_Bullet) into
 our applications. Example: loading a list of child
 objects when we only need
 to check number of objects (we are just calling `.size()` on the list)
 can cause performance bottlenecks when we are using ORM to persist
 our aggragates.
- Persisting aggragate state as a list of events is not only simpler
 but also much more aligned with DDD design.
- You should prefer returning domain events from aggragate instead of
 publishing them (no more `EventPublisher`s in aggregates). For example:

{% highlight java %}
public class MyAggregate {
    private final List<DomainEvent> pendingEvents = new ArrayList<>();
    public List<DomainEvent> getPendingEvents() {
        return pendingEvents;
    }
    public void flushEvents() {
        pendingEvents.clear();
    }
    public performOperation() {
        // do some stuff
        NameChangedEvent event = 
           new NameChangedEvent("old-name", "new-name");

        pendingEvents.add(event);
        applyEvent(event);
    }
    // ...
}

public class MyAggregateRepository {
    public MyAggregate load(UUID id) {
        List<DomainEvents> events = eventStore.loadEventsById(id);
        MyAggregate aggr = MyAggregate.recreateFrom(id, events);
        return aggr;
    }
    public void save(MyAggregate aggr) {
        eventStore.appendEvents(aggr.getId(), aggr.getPendingEvents());
        aggr.flushEvents();
    }
}

// later usage:
var aggr = repo.load(id);
aggr.performOperation();
repo.save(aggr);
{% endhighlight %}

This method of returning events from aggragate root is nothing new.
Variations of this apporach apeared as earliy as in 2013, [for example here](https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/).

- (My question after talk) You should not confuse domin events used
 to store aggragate state from integration events. Generally it is a
 bad practice to publish to other systems events used to persist aggregate.
 Mostly because you may expose state that should be private to aggragate.

- (My question after talk) How to deal with GDPR when using immutable
 event store? You should try to keep sensitive data outside of domain events.
 Later I checked that this apporach was described [here](https://twitter.com/mathiasverraes/status/927484596396199937?lang=en). 

As an alternative apporach you may use encryption as described [here](https://www.michielrook.nl/2017/11/forget-me-please-event-sourcing-gdpr/).
But for some reason I find this solution ugly.

- (Someone else's question) It is fine to use SQL databases to store domain events (at least at the
 beginning). So if you want to start your adventure with event sourcing
 use your old tried SQL db!

Overall it was a good presentation but mostly directed at the
beginners. 

You can find Jakub Pilimon blog and twitter here:

- [Blog](https://pillopl.github.io/)
- [Twitter](https://twitter.com/JakubPilimon)

#### From availability and reliability to chaos engineering. Why breaking things should be practised by Adrian Hornsby 

- Jesse Robbins is one of the fathers of Chaos Engineering 
 (see [this](https://www.youtube.com/watch?v=zoz0ZjfrQ9s) video from 2011).
- Generally we break things in production to build confidence that
 we can quickly fix real problems.

Introducing Chaos Engineering into organisation:

- Start small. Only break things in production that you are sure are 
 able to survive your "experiments". 
- First make your application resilient then test that resiliency.
 Do NOT do Chaos Engineering experiments in production that you are sure
 will kill your app.
- Test not only infrastucture but also people. If say Bob
 solves 90% of problems on production, check what will happen if other
 team members must solve such problems without Bob.

My note: I cannot resist myself from calling this technique a "bus monkey".

- Remember: **Chaos doesn't cause problems it reveals them**
- Areas to test: people, applications, network and data, infrastructure

Increasing resiliency:

- Availability is measured in "nines", e.g. four nines is 99.99%, 
 six nines is 99.9999% of time on which application works.
- four-nines is an industry standard (as of 2018)
- Easiest way to increase availability is to create multiple copies of
 the least reliable resorces. If for example you have a single 
 server that has 90% of 
 availability, having two such servers working in parallel 
 will create a system with availability of 99%.
- When you are hosting your apps in the cloud remember to use multiple 
 availibility zones (AWS lingo).
- Use auto-scaling.
- Follow infrastructure as code approach to achieve testable infrastructure.
- Your infrastructure should be immutable. Never update servers always
 create new instances and remove old one.
- Practice rolling deployments. After a fresh deploy of an application
 do NOT kill old servers immediately. Allow them to say for a while as
 a standby - just in case when your new app version will not work they
 will allow you to quickly rollback your changes.
- Never put all your databases on the same server. Use sharding to spread
 data across many databases.
- Prefer messaging to HTTP requests, message queues are more resillient.
 Send commands instead of issuing HTTP requests.
- When using HTTP remember to use circuit breaker library.
 Use exponential backoff alogirthm.
- Remember about DNS (DNS failover, smart load balancing).
- Transcient state is a state that is constantly changing, like
 webpage view counters or ad clicks counters. Do not put transcient 
 state into database, 
 instead use specialized solutions like Redis to keep it.
- Use async UI, do not wait for operation to finish, display notification
 to the user when opperation succedes or fails. See: 
 [Stop Getting In My Way! — Non-blocking UX](https://medium.com/@sophie_paxtonUX/stop-getting-in-my-way-non-blocking-ux-5cbbfe0f0158)

Chaos Engineering in Practice:

- Chaos Engineering is like a fire drills. You are doing it so that
 people will be prepared for a real fire and will not panic.
- Without excecisses people will get scary when dealing with real issues
 on production.
- How to start? Start by defining *steady state* of your application.
 In other words define when you assume that your application is working.
 For example when you have an online shop, you may assume that your 
 application is working when people click "Buy" button a certain number of 
 times per hour. This will be a steady state of your application that
 you will monitor during chaos engineering experiments to make sure
 that application is still working.
- Generally you should use business metric to define steady state.
 Measure things that bring you money!
- Define experiments. What if our DB server stops working?
 What if we have a huge spike in traffic?
- Only try to break things that you are 100% sure should not break
 (otherwise make your application resilient first).
- During chaos experiments always have an emergency stop button so that
 you can stop your experiment at any time.
- Start small! (yeah again, looks like this is very important)
- Experiment with canary deployments e.g. run experiments on 1% of total
 traffic
- Quantify results. How much time elapsed from the failure to detection of 
 that failure? How much time did it take to fix it?
 Is our monitoring working properly? Does notification (pager duty) system
 works corectly?
- Never blame a single person, instead concentracte on things that 
 you can improve.

General tips:

- During post mortems use Rule of 5 Why. 
 Why it broke? Because of X. Why X happened? Because of Y.
 Why Y happened? ... (repeat 5 times)
- Be patient.
- Be aware of cultural blocks (especially among business people).
 Generally do not tell business people that you want to 
 break your application.
 Remember chaos reveals problems not causes them.

Overall this was a very good presentation with a bit of AWS advertisment.

You can find Adrian Hornsby twitter here:

- [Twitter](https://twitter.com/adhorn)

#### Through the valley of darkness, the road to microservices by Dominik Boszko

- Ask yourself if you get any of the benefits that
 microservice architecture promised you.
- Signs that you are working with distributed monolith:
  * Change in one microservice propagates to others
    e.g. I return additional field from some REST endpoint in service A,
     but may application will start working only when I recompile service B.
  * There is too much comunications going on between teams.
  * Change in service A that is managed by my team requires approval from
    some other team
- When working with microservices Don't Repeat Yourself rule is considered
 harmfull. Microservices should be as independent from each other as possible.
- Avoid coupling between microservices. Do NOT create libraries with shared
 REST DTO's or events that will be used by many services.
 Instead introduce contracts (use tools like Swagger). 
 Each service should contain it's own copy of consumed DTO's and events.
 These DTO's should contain only the fields that the service needs.
- Be wary of `Core`s, `Platform`s, `Common`s etc. libraries that are used
 by every microservice. Microservices should be independent of each other.
 In the best case scenario you will only share security and logging related code.
- Shared libraries are bad because of transitive dependencies.
 For example team A adds a dependency on SuperXmlParser-v2.0 to the core library.
 This breaks service B maintained by team B that is using SuperXmlParser-v1.0 library.
- When using microservice architecture role of software architect changes.
 Architect no longer can enforce his decisions on teams. Instead teams are
 self organizing and cross functional and they ultimatelly decide on the design 
 and architecture of the services that they own.
- Software architect should concentrate on high level concerns like security,
 integration with other applications and best practices. Think BIG PICTURE!
- Software architects should strive to avoid micromanagement (especially when they
 have only experience with monolithic application development).
- Do not be afraid to use different technologies and architectural styles for
 different microservices (this is one of the selling points of the
 microservice architecture after all).
- Teams should be aligned with bounded context. Teams should have a deep
 knowledge of thier domains. Therefore teams are best equipped to make
 architectural decisions. This is the best usage of the top talend that
 you have hired.
- Avoid nanoservices (service that does the job of a single method).
- Do not rush into microservices. Think if you really needs benefits that
 this approach can offer you. Keep in mind additional complexity that
 comes with this approach.

This was one of the best presentations that I have seen on Devoxx.
It was based on personal experiences of Mr. Dominik. Good Job!

### Buzz

TODO: Write buzzwords and other stuff like GraphQL

### Summary

TODO

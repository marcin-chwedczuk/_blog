---
layout: post
cover: 'assets/images/devoxx_cover.jpeg'
title: Devoxx Poland 2018
date: 2018-06-25 00:00:00
tags: devcon jvmbloggers 
subclass: 'post tag-test tag-content'
categories: 'mc'
navigation: True
logo: 'assets/images/home.png'
disqus: true
---

### About conference

TODO:
- Opening and book

### My notes from presentations

#### State or events? Which shall I keep? by Jakub Pilimon

- You can find most of the topics addressed by Mr. Jakub in his blog
 post 
 [Event Storming and Spring with a Splash of DDD](https://spring.io/blog/2018/04/11/event-storming-and-spring-with-a-splash-of-ddd)
- ORM's can introduce 
 [accidental complexity](https://en.wikipedia.org/wiki/No_Silver_Bullet) into
 our applications. Example: loading a list of child
 objects when we only need
 to check number of objects (we are just calling `.size()` on the list)
 can cause performance bottlenecks when we are using ORM to persist
 our aggragates
- Persisting aggragate state as a list of events is not only simpler
 but also much more aligned with DDD design
- You should prefer returning domain events from aggragate instead of
 publishing them (no more `EventPublisher`s in aggregates). For example:

{% highlight java %}
public class MyAggregate {
    private final List<DomainEvent> pendingEvents = new ArrayList<>();
    public List<DomainEvent> getPendingEvents() {
        return pendingEvents;
    }
    public void flushEvents() {
        pendingEvents.clear();
    }
    public performOperation() {
        // do some stuff
        NameChangedEvent event = 
           new NameChangedEvent("old-name", "new-name");

        pendingEvents.add(event);
        applyEvent(event);
    }
    // ...
}

public class MyAggregateRepository {
    public MyAggregate load(UUID id) {
        List<DomainEvents> events = eventStore.loadEventsById(id);
        MyAggregate aggr = MyAggregate.recreateFrom(id, events);
        return aggr;
    }
    public void save(MyAggregate aggr) {
        eventStore.appendEvents(aggr.getId(), aggr.getPendingEvents());
        aggr.flushEvents();
    }
}

// later usage:
var aggr = repo.load(id);
aggr.performOperation();
repo.save(aggr);
{% endhighlight %}

This method of returning events from aggragate root is nothing new.
Variations of this apporach apeared as earliy as in 2013, [for example here](https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/).

- (My question after talk) You should not confuse domin events used
 to store aggragate state from integration events. Generally it is a
 bad practice to publish to other systems events used to persist aggregate.
 Mostly because you may expose state that should be private to aggragate.

- (My question after talk) How to deal with GDPR when using immutable
 event store? You should try to keep sensitive data outside of domain events.
 Later I checked that this apporach was described [here](https://twitter.com/mathiasverraes/status/927484596396199937?lang=en). 

As an alternative apporach you may use encryption as described [here](https://www.michielrook.nl/2017/11/forget-me-please-event-sourcing-gdpr/).
But for some reason I find this solution ugly.

- (Someone else's question) It is fine to use SQL databases to store domain events (at least at the
 beginning). So if you want to start your adventure with event sourcing
 use your old tried SQL db!

Overall it was a good presentation but mostly directed at the
beginners. 

You can find Jakub Pilimon blog and twitter here:

- [Blog](https://pillopl.github.io/)
- [Twitter](https://twitter.com/JakubPilimon)

### Buzz

TODO: Write buzzwords and other stuff like GraphQL

### Summary

TODO

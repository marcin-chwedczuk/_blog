---
layout: post
cover: 'assets/images/mc_cover2.jpg'
title: Java streams best practices
date: 2017-11-08 00:00:00
tags: java 
subclass: 'post tag-test tag-content'
categories: 'mc'
navigation: True
logo: 'assets/images/home.png'
disqus: true
---

In this short post I am going to present Java 8 streams 
best practices. Most of them either I figured out myself or
learned from my colleagues.

Let's start with some "obvious" things about code formatting:

* You should have at most one stream method call per line.
 This will make stream operations like `map`, `filter` and 
 `collect` easily recognizable.
{% highlight java %}
// BAD CODE:
strings.stream().filter(s -> s.length() > 2).sorted()
	.map(s -> s.substring(0, 2)).collect(Collectors.toList());

// GOOD CODE:
strings.stream()
	.filter(s -> s.length() > 2)
	.sorted()
	.map(s -> s.substring(0, 2))
	.collect(Collectors.toList());
{% endhighlight %}

* You should `import static` all of the standard 
 stream related methods. This will make code shorter, 
 easier to read and easier understand by removing all 
 unnecessary visual noise.
{% highlight java %}
// BAD CODE:
strings.stream()
	.sorted(Comparator.reverseOrder())
	.limit(10)
	.collect(Collectors.toMap(Function.identity(), String::length));

// GOOD CODE:
strings.stream()
	.sorted(reverseOrder())
	.limit(10)
	.collect(toMap(identity(), String::length));
{% endhighlight %}

* You should prefer method references to lambdas
{% highlight java %}
// AVOID:
strings.stream()
	.map(s -> s.length())
	.collect(toList());

// PREFER:
strings.stream()
	.map(String::length)
	.collect(toList());
{% endhighlight %}
Method references are easier to read since we
avoid all the visual noise generated by `->` and `()` operators.
They are also handled more efficiently by current version of Java.
Lambda expressions like `s -> s.length()` are compiled
to a private static method and an `invokedynamic` instruction.
{% highlight java %}
// s -> s.lenght() is translated into:
private static Integer lambda$main$0(String s) {
	return s.length();
}
{% endhighlight %}
Method references are compiled to only `invokedynamic` instruction.

* Give meaningful names to frequently used collector expressions.
 In most cases this means extracting collector expression into
 its own method.
{% highlight java %}
// USED FROM TIME TO TIME:
Map<Integer, Entity> entityById = entities.stream()
	.collect(toMap(Entity::getId, identity()));

// USED FREQUENTLY:
Map<Integer, Entity> entityById = entities.stream()
	.collect(ExtraCollectors.toByIdMap());

private static class ExtraCollectors {
  public static Collector<Entity,?,Map<Integer,Entity>> toByIdMap() {
	return Collectors.toMap(Entity::getId, identity());
  }
}
{% endhighlight %}
You may also consider using static import for your own frequently
used collectors.

* Use the following pattern when you sort stream values at hoc
{% highlight java %}
List<Student> result = students.stream()
	.sorted(
	  comparing(Student::getSurname)
		.thenComparing(Student::getName, reverseOrder())
		.thenComparing(Student::getAge)
		.thenComparing(Student::getId, reverseOrder())
	)
	.collect(toList());
{% endhighlight %}
Notice how we used `reverseOrder()` to reverse order of sorting
by name and id. Also bear in mind that it is always a good idea
to extract complicated comparers to its own method or a final field.

* Avoid using `peek()`.
 Try to make your streams free of side-effects.

This list is by no means complete. I will try to add some more
practices in the future. Bye!


